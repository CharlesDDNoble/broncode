import os
import docker
from time import time, sleep

class CodeHandler:
	"""This class defines a CodeHandler object

	Spawns docker containers in order to compile and execute code.

	Attributes:
		code (str): The code that will be executed in the docker container.
		flags (str): Compiler/Interpreter flags that the code will be executed with.
		code_file_name (str): The name of file that the code will be written to.
		log (str): The out log containing the error messages, stdout, and stderr
			generated from running the given code.
		time (float): The time it took for the container to spawn, run, and exit.
		max_time (float): The maximum time allowed to wait for container to exit.
	"""

	def __init__(self, code = '', flags = '', code_file_name = '', image_name = ''):
		"""Constructor for the CodeHandler class."""
		#TODO: consider logging inputs and outputs
		self.code = code
		self.flags = flags
		self.code_file_name = code_file_name
		self.image_name = image_name
		self.log = ''
		self.run_time = time()
		self.max_time = 4.0

	def run(self):
		"""Main driver function for the CodeHandler object"""
		self.write_files()
		self.log = self.handle_container()
		self.clean_up()

	def handle_container(self):
		"""Handles the creation and execution of docker containers."""
		#TODO: Rewrite this function to use interrupts instead of time()?
		error_msg_time_out =	"Something went wrong running your code:\n\t" \
								"It took too long to execute, so we stopped it!\n"
		time_out = False
		#TODO: Check returns of docker-py function calls for error
		client = docker.from_env()
	
		#create container and detach
		container = client.containers.run(self.image_name, detach = True)

		#wait until the container is running
		while "created" in container.status and not time_out:
			container.reload()
			if time() - self.run_time >= self.max_time:
				time_out = True
			sleep(0.25)

		#TODO: get docker-py to do this...  
		#TODO: convert to subprocess  
		#move the code and flag files into the container
		os.system("docker cp "+self.code_file_name+" "+container.id+":/")
		os.system("docker cp flags.txt "+container.id+":/")

		#wait until the container is exited; interrupt if time out
		self.run_time = time()
		while "running" in container.status and not time_out:
			container.reload()
			if time() - self.run_time >= self.max_time:
				time_out = True
			sleep(0.25)
		
		self.run_time = time() - self.run_time

		#kill the container if it is somehow still running?
		#this could happen if the time_out occurs
		if not "exited" in container.status:
			os.system("docker kill "+container.id)

		#set this object's log to the time out error msg or container's log
		if time_out:
			log = error_msg_time_out
		else:
			log = container.logs().decode("utf-8")

		return log

	def write_files(self):
		"""Writes this objects code and flags attributes into files."""
		#write code file
		code_file = open(self.code_file_name,"w")
		code_file.write(self.code)
		code_file.close()

		#write flag file
		flag_file = open('flags.txt',"w")
		flag_file.write(self.flags)
		flag_file.close()

	def clean_up(self):
		"""Deletes the files generated by this object's write_files function."""
		#TODO: convert to subprocess
		os.system("rm -f "+self.code_file_name)  
		os.system("rm -f flags.txt")  

	def run_time_trial(self, reps = 10):
		"""Measures the average time to handle a docker container.
	
		Spawns and executes a docker container. This process is done for
		multiple repititions. The total time to complete all the repititions
		is recorded and averaged, then returned.

		Args:
			reps (int): The number of repititions to call this objects
				run() method.

		Returns:
			float: The average time in seconds to spawn and run a docker
				container.
		"""
		start_time = time()
		for i in range(0,reps):
			self.run()
		elapsed_time = time() - start_time
		return elap/reps
